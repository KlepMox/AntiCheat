package me.rida.anticheat.checks.other;

import org.bukkit.Material;
import org.bukkit.enchantments.Enchantment;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.player.PlayerEditBookEvent;
import org.bukkit.event.player.PlayerInteractEvent;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.meta.BookMeta;

import me.rida.anticheat.AntiCheat;
import me.rida.anticheat.checks.Check;
import me.rida.anticheat.checks.CheckType;

public class ExploitA extends Check {

	public ExploitA(AntiCheat AntiCheat) {
		super("ExploitA", "Exploit", CheckType.Other, AntiCheat);

		setEnabled(true);
		setBannable(true);
		setMaxViolations(1);
	}

	@EventHandler(ignoreCancelled = true, priority = EventPriority.MONITOR)
	public void onDamage(PlayerInteractEvent e) {
		Player p = e.getPlayer();
		ItemStack is = p.getItemInHand();
		if (getAntiCheat().getLag().getTPS() < getAntiCheat().getTPSCancel()
				        || getAntiCheat().getLag().getPing(p) > getAntiCheat().getPingCancel()
				        ||is == null) {
			return;
		}
		if ((is.getType() != Material.BOOK_AND_QUILL) && (is.getType() != Material.WRITTEN_BOOK)) {
			return;
		}
		if (is.getEnchantments().size() > 0) {
			for (Enchantment ench : is.getEnchantments().keySet()) {
				is.removeEnchantment(ench);
			}

			e.setCancelled(true);
			getAntiCheat().logCheat(this, p, "[3] Book and Quill Exploit", "(Type: A)");
			p.getInventory().removeItem(new ItemStack[] { is });
		}
	}

	@EventHandler(ignoreCancelled = true, priority = EventPriority.MONITOR)
	public void onEdit(PlayerEditBookEvent e) {
		BookMeta b = e.getNewBookMeta();
		Player p = e.getPlayer();
		if (b.getEnchants().size() > 0) {
			e.setCancelled(true);
			e.getPlayer().getInventory().remove(Material.BOOK_AND_QUILL);
			getAntiCheat().logCheat(this, p, "[2] Book and Quill Exploit", "(Type: A)");
		}
	}

}
